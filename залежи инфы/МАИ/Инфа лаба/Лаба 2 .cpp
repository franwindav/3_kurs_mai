/**
	Общий принцип работы:

	Два исходных массива заполняются случайными числами
	После этого поочередно передаются в функцию SortArray, где исходя из данных этих массивов
	Заполняется временный массив, в котором подсчитывается кол-во подряд идущих положительных элементов
	После этого вызывается функция GetMaxArrayElement, куда передается этот самый массив
	Функция ищет и возвращает максимальный элемент данного массива
	- Это и есть требуемый результат
**/

// # - препроцессорные директивы
// Подключаем необходимые заголовочные файлы
#include <iostream>
#include <time.h>
#include <conio.h>

// Для удобства задаем константой размер массивов из задачи
const int ARRAYSIZE = 15;

/*
	Вспомогательная функция для получения максимального элемента (типа INT)
	Входящего одномерного массива

	Оба аргумента являются обязательными

	@Array	- Целочисленный массив на ARRAYSIZE элементов ( в данном случае ARRAYSIZE не играет никакой роли)
	@size	- Целочисленная переменная задающая размер массива Array, используется для корректно работы цикла

	@return Max array value
*/
int GetMaxArrayElement(int Array[ARRAYSIZE], int size)
{
	// Локальная переменная целочисленного типа 
	int max = 0;

	// Цикл с предусловием. Переменная i изменяется от нуля до size - 1
	for (int i = 0; i < size; i++)
	{
		// Если текущий элемент массива больше значения переменной max, то присваиваем переменной max текущее значение
		// Элемента массива Array с индексом i
		if (Array[i] > max)
			max = Array[i];
	}

	// Возвращаем максимальный элемент массива
	return max;
}

/*
	Функция типа VOID (не должна возвращать значение) сортировки входящего массива

	@Array	- Вещественный массив
	@iTemp	- Указатель на начало массива iTemp для последующего заполнения данного массива
	@size	- Целочисленная переменная задающая размер массива Array, используется для корректно работы цикла
*/ 
void SortArray(double Array[], int *iTemp, int size)
{
	// Локальная переменная целочисленного типа 
	int count = 0;

	// Цикл с предусловием. Переменная i изменяется от нуля до size - 1
	for (int i = 0; i < size; i++)
	{
		// Изначально значение элемента массива iTemp с индексом i задаем равным нулю 
		iTemp[i] = 0;

		// Если текущий элемент массива больше нуля (т.е. подходит нам)
		// То увеличиваем значение переменной count на один
		// Иначе обнуляем значение данной переменной
		if (Array[i] > 0)
			count++;
		else
			count = 0;

		// Присваиваем текущему элементу массива iTemp значение переменной count
		iTemp[i] = count;
	}
}

// Точка входа в программу
int main()
{
	// Вызываем функцию srand из заголовочного файла time.h и передаем в качестве аргумента текущий TIMESTAMP
	srand(time(NULL));

	// Создаем и сразу же инициализиуем нулями два целочисленных массива
	// @count	- массив для хранения результатов
	// @iTemp	- массив для хранения результатов
	int count[2] = {0}, iTemp[ARRAYSIZE] = {0};

	// Создаем и сразу же инициализиуем нулями два вещественных массива
	double A[ARRAYSIZE] = {0}, B[ARRAYSIZE] = {0};

	// Цикл с постусловием
	do
	{
		// Очищаем консоль
		system("cls");

		// Заполняем два массива согласно условиям работы случайными числами
		// И выводим значения для анализа и дальнейшей проверки результатов 
		for (int i = 0; i < ARRAYSIZE; i++)
		{
			A[i] = rand() - rand();
			B[i] = rand() - rand();
			printf("%8.1f | %8.1f\n", A[i], B[i]);
		}

		// Вызываем функцию SortArray и передаем в неё:
		// - Массив случайных чисел A
		// - Массив для временного хранения результатов
		// - Размер массивов (совпадает для двух первых аргументов)
		// На выходе в массиве iTemp получаем кол-во поряд расположенных положительных чисел в массиве A
		// --------
		// Вызываем функцию GetMaxArrayElement и передаем в неё:
		// - Массив для временного хранения результатов
		// - Размер массивов (совпадает для двух первых аргументов)
		// Функция возвращает максимальный элемент массива iTemp
		// Это значение мы присваиваем нулевому элементу массива count
		// - Это и есть ответ для первого массива
		SortArray(A, iTemp, ARRAYSIZE);
		count[0] = GetMaxArrayElement(iTemp, ARRAYSIZE);

		// Проделываем аналогичную операцию со вторым массивом
		SortArray(B, iTemp, ARRAYSIZE);
		count[1] = GetMaxArrayElement(iTemp, ARRAYSIZE);

		// Выводим результаты на консоль
		printf("\ncount[0] = %d\ncount[1] = %d\n", count[0], count[1]);

	// Цикл: пока нажатая на клавиатуре кнопка НЕ ESC - начинаем цикл по новой
	} while (_getch() != 27);

	// Конец работы. Завершаем программу с кодом 0 (сигнал об отсутствии ошибок)
	return 0;
}